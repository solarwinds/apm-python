""" This module provides a SolarWinds-specific exporter.

The exporter translates OpenTelemetry spans into AppOptics events so that the instrumentation data
generated by an OpenTelemetry-based agent can be processed by the SolarWinds backend.
"""

import logging

from opentelemetry.sdk.trace.export import SpanExporter

from solarwinds_apm.extension.oboe import (
    Context,
    Metadata
)
from solarwinds_apm.w3c_transformer import W3CTransformer


logger = logging.getLogger(__file__)


class SolarWindsSpanExporter(SpanExporter):
    """SolarWinds custom span exporter for the SolarWinds backend.
    Initialization requires a liboboe reporter.
    """
    def __init__(self, reporter, *args, **kw_args):
        super().__init__(*args, **kw_args)
        self.reporter = reporter

    def export(self, spans):
        """Export to AO events and report via liboboe.

        Note that OpenTelemetry timestamps are in nanoseconds, whereas AppOptics expects timestamps
        to be in microseconds, thus all times need to be divided by 1000.
        """
        for span in spans:
            md = self._build_metadata(span.get_span_context())
            if span.parent and span.parent.is_valid:
                # If there is a parent, we need to add an edge to this parent to this entry event
                logger.debug("Continue trace from {}".format(md.toString()))
                parent_md = self._build_metadata(span.parent)
                evt = Context.createEntry(md, int(span.start_time / 1000),
                                         parent_md)
            else:
                # In OpenTelemrtry, there are no events with individual IDs, but only a span ID
                # and trace ID. Thus, the entry event needs to be generated such that it has the
                # same op ID as the span ID of the OTel span.
                logger.debug("Start a new trace {}".format(md.toString()))
                evt = Context.createEntry(md, int(span.start_time / 1000))
            evt.addInfo('Layer', span.name)
            evt.addInfo('Language', 'Python')
            for k, v in span.attributes.items():
                evt.addInfo(k, v)
            self.reporter.sendReport(evt, False)

            for event in span.events:
                if event.name == 'exception':
                    self._report_exception_event(event)
                else:
                    self._report_info_event(event)

            evt = Context.createExit(int(span.end_time / 1000))
            evt.addInfo('Layer', span.name)
            self.reporter.sendReport(evt, False)

    def _report_exception_event(self, event):
        evt = Context.createEvent(int(event.timestamp / 1000))
        evt.addInfo('Label', 'error')
        evt.addInfo('Spec', 'error')
        evt.addInfo('ErrorClass', event.attributes.get('exception.type', None))
        evt.addInfo('ErrorMsg', event.attributes.get('exception.message',
                                                     None))
        evt.addInfo('Backtrace',
                    event.attributes.get('exception.stacktrace', None))
        # add remaining attributes, if any
        for k, v in event.attributes.items():
            if k not in ('exception.type', 'exception.message',
                         'exception.stacktrace'):
                evt.addInfo(k, v)
        self.reporter.sendReport(evt, False)

    def _report_info_event(self, event):
        print("Found info event")
        print(dir(event))
        print(event)
        evt = Context.createEvent(int(event.timestamp / 1000))
        evt.addInfo('Label', 'info')
        for k, v in event.attributes.items():
            evt.addInfo(k, v)
        self.reporter.sendReport(evt, False)

    @staticmethod
    def _build_metadata(span_context):
        return Metadata.fromString(
            W3CTransformer.traceparent_from_context(span_context)
        )
